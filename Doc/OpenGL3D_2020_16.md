[OpenGL 3D 2020 第16回]

# 関数ポインタは<br>仮想関数に進化した！

## 習得目標

* クラスの継承について
* 関数ポインタと仮想関数それぞれの利点と欠点
* 重力の扱い

## 1. 継承

### 1.1 オブジェクト指向プログラミングについて

ゲームに登場するアクターにはさまざまな種類があるため、それぞれに異なるプログラムを作成しなくてはなりません。しかし、すべての動作が違っているアクターというのはあまりなくて共通する部分も多いのが普通です。

そのため、共通部分と種類ごとに異なる部分に分けてプログラムを作っていくことになります。異なる部分を作るには、

1. アクターに名前やタグをつけて`if`や`switch`で処理を分ける。
2. 関数ポインタに異なる関数やラムダ式を指定する。

といった方法があり、これらはほとんどの状況で十分に機能します。しかし、ゲームの内容が高度化し複雑さを増していくにつれて、これらの方法だけではバグもなく高速に動作するプログラムを書くことが困難になってきました。

そこで登場したのが「オブジェクト指向」という考え方です。ここでいう「オブジェクト」とは「データとそれに関連する機能(プログラム)をまとめたもの」です。そして、オブジェクト指向プログラミングとは、

>主要な構成部品としてオブジェクトを使うプログラミング技法

のことです。データと機能を別々に扱うのではなく、両者を一体として扱うことで組み合わせパターンを減らし、プログラム全体の複雑さを抑えることができます。

オブジェクトを主体とするための主な技法には、以下のようなものがあります。

>* カプセル化: オブジェクトに含まれるデータを操作する権限を決められた機能に制限します。プログラムではそれらの機能だけを使ってオブジェクトを操作します。プログラムはデータの詳細を知る必要がなくなり、プログラムの複雑さを減らすことができます。
>* 抽象化: 本質的でないオブジェクトの機能をオブジェクト外からは使用できないようにします。オブジェクトについて必要最小限の操作だけが公開されるため、プログラムの複雑さを減らすことができます。
>* 継承: あるオブジェクトの特殊なバージョンを作ることができるようにします。特殊でない部分についてはデータと機能を流用することで重複部分がなくなり、プログラムの複雑さを減らすことができます。
>* ポリモーフィズム(<ruby>多態<rt>たたい</rt></ruby>): 元になったオブジェクトの機能について、特殊なバージョンごとに異なる内容を定義できるようにします。機能の詳細を元のオブジェクトから分離することで、プログラムの複雑さを減らすことができます。

<br>

>**【オブジェクト指向プログラミングは言語を選ばない】**<br>
>オブジェクト指向プログラミングは「単なる設計技法」なので、C言語やアセンブリ言語でも「オブジェクト指向」プログラミングは可能です。しかし、C++のように「オブジェクト指向プログラミングをサポートする機能」を持つ言語のほうが、オブジェクト指向プログラミングを行いやすいのは間違いありません。

### 1.2 ポリモーフィズムと仮想関数

現在、明示的な更新が必要なアクターはゾンビアクターだけなので、`MainGameScene`クラスにプログラムを書いても特に問題はありませんでした。しかし、これから追加するさまざまなアクターの更新処理を全部`MainGameScene`に書いていくと、とても見通しの悪いプログラムになってしまいます。

そこで、「ポリモーフィズム」を使って`Actor`の状態を更新する処理を、アクターごとに定義できるようにしたいと思います。

C++におけるポリモーフィズムは「継承」と「仮想関数」によって実現されます。C++の全ての構造体、共用体、クラスは自動的に「継承」可能になるため、「継承」について特に準備をする必要はありません。

「継承」を行ったとき、元になったクラスのことを「基底クラス」、「基底クラス」を継承したクラスのことを「派生クラス」と呼びます。派生クラスの参照やアドレスは、基底クラスの参照変数やポインタ変数に代入することができます。

次に、基底クラスの関数を「仮想関数」にしなくてはなりません。メンバ関数宣言の先頭に`virtual`(バーチャル)キーワードを付けると、そのメンバ関数は「仮想関数」になります。

>**【仮想関数？　仮想メンバ関数？】**<br>
>仮想関数にできるのはメンバ関数だけなので、すべての仮想関数はメンバ関数でもあります。そのためわざわざ「仮想メンバ関数」と書くことはほとんどありません。仮想関数は派生クラスにおいて定義を上書きできます。

仮想関数の定義を上書きすることを「オーバーライド」といいます(オーバーライドは「～に優先する」という意味です)。

基底クラスのポインタ変数に派生クラスのアドレスを代入し、ポインタ変数経由で仮想関数を呼び出すと上書きした定義が使われます。この「基底クラスのポインタだけを使って派生クラスごとに異なる定義を実行すること」が「ポリモーフィズム」の正体です。

通常のメンバ関数と仮想関数の違いを以下に示します。まず通常のメンバ関数の例ですが、`a`変数経由で`Func`メンバ関数を呼び出すと`A::Func`が実行されることに注目してください。

```c++
#include <iostream>
struct A {
    void Func() { std::cout << "I am A.\n"; }
};

struct B : public A {
    void Func() { std::cout << "I am B.\n"; }
};

void FuncA(A& a) { a.Func(); }
void FuncB(B& b) { b.Func(); }

int main() {
    B b;
    FuncA(b); // "I am A."が表示される.
    FuncB(b); // "I am B."が表示される.
}
```

`FuncA`関数の引数も`FuncB`関数の引数も`b`なので、どちらも`I am B.`と表示されてもよさそうなものですが、実際にはそうはなりません。なぜなら、C++では`a`が`Aの参照`ということだけを考慮し、実際の型は考慮されないからです。

こうなっているのは、例えば`FuncA`の定義が別のファイルに書いてあった場合、引数`a`が実際に指している型を取得する方法がないからです。

次に`Func`を仮想関数にした例を示します。違いは`virtual`の有無だけですが、出力が変化しています。

```c++
#include <iostream>
struct A {
    virtual void Func() { std::cout << "I am A.\n"; }
};

struct B : public A {
    virtual void Func() { std::cout << "I am B.\n"; }
};

void FuncA(A& a) { a.Func(); }
void FuncB(B& b) { b.Func(); }

int main() {
    B b;
    FuncA(b); // "I am B."が表示される.
    FuncB(b); // "I am B."が表示される.
}
```

仮想関数を使うと`FuncA(b)`の結果も`I am B.`になります。`FuncA`の定義が別ファイルにあっても同じ結果になります。

これが可能なのは、クラスに仮想関数が含まれる場合、そのクラスおよび派生クラスの変数には「仮想関数が実行されたとき実際に呼び出すべき関数一覧」というデータが追加されるからです。

`FuncA`が、引数`a`が実際に指している型を知りようがないのは変わりませんが、この関数一覧があるおかげで実際に呼び出す関数を決められるわけです。

>**【基底・派生以外の呼び方】**<br>
> 基底クラスと派生クラスの呼び方は言語や書籍によってさまざまです。よく使われる呼び方を以下に示します。
>| 元になったクラスの呼び方 | 継承したクラスの呼び方 |
>|:--------------:|:------------:|
>| 基底クラス     | 派生クラス   |
>| 親クラス       | 子クラス     |
>| スーパークラス | サブクラス   |
>| ベースクラス   | サブクラス   |

### 1.3 仮想関数を追加する

それでは`Actor`クラスに仮想関数を追加しましょう。`Actor.h`を開き、`Actor`クラスの定義を次のように変更してください。

```diff
 class Actor
 {
 public:
   Actor() = default;
-  ~Actor() = default;
+  virtual ~Actor() = default;
   Actor(std::string actorName, const Mesh::Primitive* prim,
     std::shared_ptr<Texture::Image2D> tex, const glm::vec3& pos);

   void Update(float deltaTime);
+  virtual void OnUpdate(float) {}

   // 描画の種類.
   enum DrawType {
```

仮想関数は`OnUpdate`(オン・アップデート)とします。あとでプログラムしますが、この仮想関数は`Update`メンバ関数の中で実行されます。

また、C++でポリモーフィズムを使う場合はデストラクタも仮想関数にします。`new` や `std::make_shared` による動的メモリ確保を行う場合、適切なデストラクタを呼び出せないと正しくメモリを開放できないからです。

次に`Actor.cpp`を開き、`Update`メンバ関数に次のプログラムを追加してください。

```diff
 void Actor::Update(float deltaTime)
 {
+  OnUpdate(deltaTime);
+
   // 座標を更新.
   position += velocity * deltaTime;
```

このような「メンバ関数の中で仮想関数を呼び出す」仕組みは、「メンバ関数の特定の処理をカスタマイズ」したい場合に使います。`OnUpdate`仮想関数は「`Update`メンバ関数において派生クラスごとの追加の処理を挿入できるポイント」になるわけです。

これで基底クラスの準備は完了です。

### 1.4 ZombieActorクラスを定義する

`Actor`クラスの特殊なバージョンとして、ゾンビアクターを表す`ZombieActor`クラスを作成します。`Src`フォルダに新しく`Actors`(アクターズ)という名前のフォルダを作成し、その中に`ZombieActor.h`というヘッダファイルを追加してください。

>「追加→新しい項目」で作成する場合、「場所」を`Src\Actors`としておけば自動的にフォルダを作成してくれます。

フォルダを分けるのは、今後`Actor`の派生クラスが増えていったとき、`Src`フォルダのファイルが多すぎて管理しにくくなるのを防ぐためです。

>**【ファイルとフィルタの違い】**<br>
>なお、Visual Studioのソリューションエクスプローラーにフォルダは表示されません。ソリューションエクスプローラーの「フィルタ」は、ドライブ上のフォルダとは別のルールでファイルをグループ分けするための、Visual Studio独自の機能だからです。フォルダ構成とソリューションエクスプローラの表示を一致させたい場合は「追加→新しいフィルター」で`Actors`というフィルタを作り、そこにファイルを追加する必要があります。

それでは、追加した`ZombieActor.h`を開き、次のプログラムを追加してください。

```diff
+/**
+* @file ZombieActor.h
+*/
+#ifndef ZOMBIEACTOR_H_INCLUDED
+#define ZOMBIEACTOR_H_INCLUDED
+#include "../Actor.h"
+
+/**
+* ゾンビアクター.
+*/
+class ZombieActor : public Actor
+{
+public:
+  ZombieActor(const glm::vec3& pos, float rotY);
+  virtual ~ZombieActor() = default;
+
+  virtual void OnUpdate(float) override;
+};
+
+#endif // ZOMBIEACTOR_H_INCLUDED
```

C++において「継承」を行うには、クラス(または構造体)の名前の直後に`:`(コロン)と「継承方法」を書き、そのあとに「基底クラス」の名前を書きます。

「継承方法」には以下の3つのいずれかを指定できます。

>* `public`継承: 派生クラスを基底クラスとしても扱えるようにします。ポリモーフィズムを使う場合はこの継承方法を指定しなければなりません。
>* `private`継承: 派生クラスのメンバの中で基底クラスのメンバを使えるようにします。基底クラスとして使うことはできないので、ポリモーフィズムはできません。
>* `protected`継承: `private`の性質に加えて、派生クラスからさらに派生したクラスでも`protected`継承した基底クラスのメンバを使えるようにします。`private`継承と同じくポリモーフィズムはできません。

説明を読むと分かるように、`private`(プライベート)継承と`protected`(プロテクテッド)継承ではポリモーフィズムを使えません。ポリモーフィズムを使う場合は常に`public`を選択する必要があります。

なお、`private`継承と`protected`継承は扱いが難しいので、まずは`public`継承を使えるようにすることを考えてください。

派生クラスで仮想関数をオーバーライドするときは、関数宣言の末尾に`override`(オーバーライド)キーワードを付けます。`override`を付けると、基底クラスに対応する仮想関数がない場合にエラーが報告されるので、名前や引数を間違えるというミスを防止できます。

>**【..の意味】**<br>
>インクルード文に出てきた`../`(2連続ドット)は「一階層上のフォルダ」を表します。インクルード文には絶対パス(`c:/Program Files/AnyApp/app.h`のような)か相対パス(`../Actor.h`のような)を書くことができます。相対パスの場合、インクルード文を書くファイルの存在するフォルダを基準とします。`Actor.h`はひとつ上のフォルダにあるので、`../`を使って`../Actors.h`のように書く必要があります。<br>
>余談ですが、「現在のフォルダ」を指す`./`(ひとつのドット)も存在します。例えば`Actor.h`と`./Actor.h`は同じ意味です。あまりないことですが、コンパイラ設定で基準フォルダを追加していて、そのフォルダに同名のファイルがあるとき、ファイルを明示するために使うことがあります。

<br>

>**【インクルード文のフォルダ区切りには/(スラッシュ)を使うこと】**<br>
>Visual C++のインクルード文では`/`と`\`のどちらでも、フォルダの区切り記号として使うことができます。ただし、`C++`言語仕様では`/`が基本で、`\`が使えるかどうかは実装が決めることになっています。そのため、Visual C++では`\`も使えるようになっているわけです。しかし、よほどの事情(家族や恋人を人質に取られて`\`を使うように脅されているなど)がない限りはインクルード文では`/`(スラッシュ)を使ってください。<br>
>また、これはC++の仕様でしかないため、他のOSやアプリではそれぞれのルールに従ってください。例えばWindowsのフォルダ区切り記号は`\`です。

### 1.5 ZombieActorクラスのメンバ関数を定義する

次に、`Src\Actors`フォルダに`ZombieActor.cpp`というCPPファイルを追加してください。追加した`ZombieActor.cpp`を開き、次のプログラムを追加してください。

```diff
+/**
+* @file ZombieActor.cpp
+*/
+#include "ZombieActor.h"
+#include "../GameData.h"
+
+/**
+* コンストラクタ.
+*
+* @param pos    アクターを配置する座標.
+* @param rotY   アクターの向き.
+*/
+ZombieActor::ZombieActor(const glm::vec3& pos, float rotY) :
+  Actor("zombie", nullptr,
+    std::make_shared<Texture::Image2D>("Res/zombie_male.tga"),
+    pos)
+{
+  // ここにゾンビアクターを初期化するプログラムを移動する.
+}
+
+/**
+* ゾンビの状態を更新する.
+*
+* @param deltaTime 前回の更新からの経過時間(秒).
+*/
+void ZombieActor::OnUpdate(float deltaTime)
+{
+  // ここにゾンビアクターを更新するプログラムを移動する.
+}
```

派生クラスのコンストラクタでは、まず基底クラスのコンストラクタを実行して基底クラスを利用可能にしなくてはなりません。これは「メンバ初期化子」または「メンバイニシャライザ」と呼ばれる構文で行います。

<pre class="tnmai_code"><strong>【書式】</strong>
派生クラスのコンストラクタ(引数1, 引数2, ...) :
  基底クラスのコンストラクタ(来てクラスのコンストラクタ引数, ...),
  派生クラスのメンバ変数コンストラクタ(メンバ変数コンストラクタの引数, ...),
  ...
{
  // 関数本体
}
</pre>

メンバ初期化子を使うには、まずコンストラクタの引数リストのあとに`:`(コロン)を書きます。コロンに続いて基底クラスのコンストラクタを書き、さらに続けてメンバ変数のコンストラクタを書きます。

メンバ変数については宣言と同時に初期値を指定する方法があるので、通常はそちらを使います。しかし、初期値が引数によって決まる場合はメンバ初期化子を使う必要があります。

`Actor`コンストラクタには名前やプリミティブ、テクスチャを指定することができました。しかしゾンビアクターではこれらは常に同じで変化しません。そこでゾンビアクターのコンストラクタ引数からは除外し、メンバ初期化子で指定するようにしています。

派生クラスで基底クラスの汎用性が不要になる場合、このようにコンストラクタ引数を減らすことで無駄な記述をなくすことができます。

>**【メンバ初期化子の順序に注意！】**<br>
>メンバ変数の初期化は常に宣言順に行われます。メンバ初期化子の順序が宣言順と違っていると、初期化されていないメンバ変数を使ってしまうことがあります。そのため、メンバ初期化子の順序が常に宣言順になるようにしておくと安全です。もしメンバ変数の宣言順を入れ替えるときはメンバ初期化子の順序も入れ替えなくてはならないので、特に注意してください。

コンストラクタおよび`Update`メンバ関数には、`MainGameScene.cpp`に書いてあるゾンビの初期化と更新処理を切り取って貼り付けることにします。

### 1.6 ゾンビの初期化処理を切り取って貼り付ける

まずはコンストラクタを完成させます。ゾンビの初期化処理は `MainGameScene::Initialize` メンバ関数の中に書かれているはずなので、まずはその部分を切り取って、コンストラクタに貼り付けましょう。

`MainGameScene.cpp`を開き、ゾンビを作成する以下のプログラムを`Ctrl+X`で切り取ってください。

```diff
     pos.z = std::uniform_real_distribution<float>(-18, 18)(random);
     // アクターを作成.
     std::shared_ptr<Actor> actor =
       std::make_shared<Actor>("zombie", pPrimitive, texZombie, pos);

-    // アクターの耐久値を設定.
-    actor->health = 3;
-    // 垂直円柱型の衝突判定を設定.
-    actor->SetCylinderCollision(1.7f, 0, 0.5f);
-    // 衝突処理を設定.
-    actor->OnHit = [](Actor& a, Actor& b, void* option) {
-
-            ・
-            ・
-            ・
-
-    // アクターのY軸回転を設定.
-    actor->rotation.y =
-      std::uniform_real_distribution<float>(0, glm::radians(360.0f))(random);
-    // アニメーションを設定.
-    actor->SetAnimation(GameData::Get().anmZombieMaleWalk);
-    actor->state = Actor::State::walk;
     // 作成したアクターを、アクターリストに追加.
     actors.push_back(actor);
   }
```

そして、`ZombieActor.cpp`を開き、コンストラクタに貼り付けてください。

```diff
 ZombieActor::ZombieActor(const glm::vec3& pos, float rotY) :
   Actor("zombie", nullptr,
     std::make_shared<Texture::Image2D>("Res/zombie_male.tga"),
     pos)
 {
-  // ここにゾンビアクターを初期化するプログラムを移動する.
+    // アクターの耐久値を設定.
+    actor->health = 3;
+    // 垂直円柱型の衝突判定を設定.
+    actor->SetCylinderCollision(1.7f, 0, 0.5f);
+    // 衝突処理を設定.
+    actor->OnHit = [](Actor& a, Actor& b, void* option) {
+
+            ・
+            ・
+            ・
+
+    // アクターのY軸回転を設定.
+    actor->rotation.y =
+      std::uniform_real_distribution<float>(0, glm::radians(360.0f))(random);
+    // アニメーションを設定.
+    actor->SetAnimation(GameData::Get().anmZombieMaleWalk);
+    actor->state = Actor::State::walk;
+
 }

 /**
 * ゾンビの状態を更新する.
```

### 1.7 オブジェクト指向とthisポインタ

続いて、ゾンビの初期化処理を移動させたことで発生したエラーを解消していきます。

ところで、メンバ関数と関数ポインタの構文は全く同じです。なぜなら「関数のアドレスを指定して実行する」という点において両者に違いはないからです。

しかし、メンバ関数には「オブジェクト指向」を実現するために、関数ポインタにはない機能が追加されています。それが`this`(ズィス、ディス、ジス…各自好きな読みで)ポインタです。

`this`ポインタは内部的にはメンバ関数の0番目の引数として、コンパイラによって自動的に渡されます。実際、貼り付けたプログラムの`actor`変数は`this`で置き換えることができます。例えば、

> actor->health = 3;

は

> this->health = 3;

と置き換えられます。この置き換えが可能なのは、`ZombieActor`コンストラクタを`actor`オブジェクトを操作するための関数として作っているからです。

実際にC言語でオブジェクト指向を実践するときは、関数の第1引数に関連する構造体のポインタを指定することがよくあります。例えば`OnHit`関数ポインタは、第1引数に`OnHit`関数ポインタを所有するオブジェクトの参照が渡されることを想定しています。

また、メンバ変数とメンバ関数であることが明らかな場合は`this->`を省略できます。さきほどの例でいうと、

> actor->health = 3;

は

> health = 3;

とすることができます。つまり、全てのメンバ関数は暗黙的に同じクラスに属するすべてのメンバを使うことができるのです。これによって、データと機能を一体として扱うことを容易にしているわけです。

事実、`OnHit`関数ポインタに指定するラムダ式では常に`a.`を使う必要がありました。これは明らかに冗長なうえ、衝突相手である`b`と書き間違える危険性もあります。メンバ関数ならばこれらの問題は解消されます。

>**【オブジェクト自身を指す名前】**<br>
>`this`のかわりに`self`(セルフ)や`Current`(カレント)などの名前を使うプログラミング言語もあります。名前が違っても役割はほぼ同じです。

<pre class="tnmai_assignment">
<strong>【課題01】</strong>
貼り付けたプログラムから全ての<code>actor-&gt;</code>を削除しなさい。
</pre>

それから、Y軸回転については引数で受け取るように書き換えます。現在のゾンビは画面内のランダムな位置に出現させていますが、今後、例えばゾンビが特定の位置や方向から現れるようにしたい場合、ゾンビの向きを制御できたほうが便利でしょう。

ゾンビのY軸回転を初期化するプログラムを次のように変更してください。

```diff
 {
     // アクターの耐久値を設定.
     health = 3;
-    // アクターのY軸回転を設定.
-    rotation.y =
-      std::uniform_real_distribution<float>(0, glm::radians(360.0f))(random);
+    rotation.y = rotY;
     // アニメーションを設定.
     SetAnimation(GameData::Get().anmZombieMaleWalk);
     state = Actor::State::walk;
```

これでコンストラクタのエラー対応は完了です。

### 1.8 ZombieActorクラスのインスタンスを作成する

次にゾンビアクターを作成する部分を修正します。

ところで、オブジェクト指向では「変数定義や`new`などによって作られるクラスの実体」のことを「インスタンス」といいます。英語では`instance`と書き、その意味は「実例、事実、場合」といったものです。

実はこれは「即時の」を意味する形容詞`instant`(インスタント)の名詞形なのですが、インスタントは`in`(近くに)と`stant`(立つ、ある)を組み合わせた単語で、「近くにある→すぐ使える」という連想から「即時の」という意味を持つとされています。

そして、インスタンスの場合は「近くにある**もの**→手近な例」という連想から「実例、事実、場合」という意味になるわけです。

オブジェクト指向では、クラスを実体化した存在のことを「実体化したもの→実例」ということから「インスタンス」と呼んでいます。

さて、前置きはここまでにして、`ZombieActor`クラスのインスタンスを作成しましょう。「インスタンスの作成」といっても、結局はこれまでやってきたことの呼び方を変えただけです。

`ZombieActor`クラスを使うために、まずはヘッダファイルをインクルードします。`MainGameScene.cpp`を開き、`SceneManager.h`のインクルード文の下に次のプログラムを追加してください。

```diff
 #include "MainGameScene.h"
 #include "GameData.h"
 #include "SceneManager.h"
+#include "Actors/ZombieActor.h"
 #include <glm/gtc/matrix_transform.hpp>
 #include <iostream>
 #include <algorithm>
```

次に、ゾンビアクターを作成する`std::make_shared`のテンプレートパラメータを`Actor`から`ZombieActor`に変更し、引数を`ZombieActor`コンストラクタのものと置き換えます。

`Initialize`メンバ関数にあるゾンビアクターを作成するプログラムを、次のように変更してください。

```diff
   // ゾンビアクターを作成.
-  const Mesh::Primitive* pPrimitive = &GameData::Get().primitiveBuffer.Get(4);
   for (size_t i = 0; i < 100; ++i) {
     glm::vec3 pos(0);
     pos.x = std::uniform_real_distribution<float>(-18, 18)(random);
     pos.z = std::uniform_real_distribution<float>(-18, 18)(random);
+    // アクターのY軸回転を設定.
+    float rotY =
+      std::uniform_real_distribution<float>(0, glm::radians(360.0f))(random);
     // アクターを作成.
     std::shared_ptr<Actor> actor =
-      std::make_shared<Actor>("zombie", pPrimitive, texZombie, pos);
+      std::make_shared<ZombieActor>(pos, rotY);
     // 作成したアクターを、アクターリストに追加.
     actors.push_back(actor);
   }
```

`std::make_shared`関数のテンプレートパラメータを`ZombieActor`に変えたにも関わらず、`actor`変数のパラメータは`Actor`のままになっている点に注目してください。

`ZombieActor`は`Actor`を継承しているので、基底クラスである`Actor`のポインタに代入することができるのです。

なお、ゾンビの向き(Y軸回転)は、ひとまず0～360°のあいだでランダムに決めることにしました(変更前のプログラムと同じ動作です)。

### 1.9 外部からアクターを追加できるようにする<br>(newActorsをメンバ変数にする編)

次はゾンビアクターの更新処理を`ZombieActor`クラスに移すのですが、ゾンビアクターの更新処理の中で新規アクターを作成したり、プレイヤーアクターを参照することがあります。

アクターを作成するだけなら問題はないのですが、作成されたアクターは`newActors`配列に追加する必要があります。しかし`newActors`は`MainGameScene`クラスのメンバなので、`ZombieActor`からは使えません。

そこで、`newActors`変数を`MainGameScene`クラスのメンバ変数として定義しなおし、さらに新規アクターを追加するためのメンバ関数を作成します。そして、新規アクターを追加したいクラスには`MainGameScene`のポインタを持たせます。

新規アクターを追加するときは、ポインタ経由でメンバ関数を呼び出してもらいます。

まず`newActors`をメンバ変数として定義しなおします。`MainGameScene.h`を開き、`MainGameScene`クラスの定義に次のプログラムを追加してください。

```diff
   // マウスカーソル座標.
   glm::vec3 posMouseCursor = glm::vec3(0);

   ActorList actors; // アクター配列.
+  ActorList newActors; // 新規アクター配列.
   ActorPtr playerActor; // プレイヤーアクター.

   // 出現させる敵の数.
   size_t appearanceEnemyCount = 10;
```

それから、クラスを初期化するときに`newActors`配列の容量を予約しておきます。メンバ変数はローカル変数と異なり関数が終了しても削除されないので、最初に一度予約すれば十分です。`MainGameScene.cpp`を開き、`Initialize`メンバ関数に次のプログラムを追加してください。

```diff
   // 標準マウスカーソルを非表示にする.
   glfwSetInputMode(gamedata.window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
+
+  // 新規アクター追加用の配列のサイズを予約する.
+  newActors.reserve(100);

   std::cout << "[情報] MainGameSceneを開始.\n";
   return true;
 }
```

そして、ローカル変数版の`newActors`はもう必要がないので削除します。`Update`メンバ関数を次のように変更してください。

```diff
 void MainGameScene::Update(GLFWwindow* window, float deltaTime)
 {
   // アクターの行動を処理.
-  ActorList newActors; // 新規アクターの配列.
-  newActors.reserve(100);
   for (auto& e : actors) {
     // ゾンビアクターの場合.
     if (e->name == "zombie") {
```

### 1.10 外部からアクターを追加できるようにする<br>(新規アクター追加用のメンバ関数を作る編)

次に、新規アクターを追加するためのメンバ関数と、プレイヤーアクターを参照するためのメンバ関数を作成します。メンバ関数名は`AddActor`(アド・アクター)と`GetPlayerActor`(ゲット・プレイヤーアクター)とします。

`MainGameScene.h`を開き、`MainGameScene`クラスの定義に次のプログラムを追加してください。

```diff
   void Update(GLFWwindow*, float deltaTime);
   void Render(GLFWwindow*) const;
   void Finalize();
+
+  void AddActor(ActorPtr p);
+  ActorPtr GetPlayerActor();

 private:
   std::shared_ptr<Texture::Image2D> texGround = nullptr;
   std::shared_ptr<Texture::Image2D> texTree = nullptr;
```

続いて`MainGameScene.cpp`を開き、`Finalize`メンバ関数の定義の下に、次のプログラムを追加してください。

```diff
   glfwSetInputMode(GameData::Get().window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);

   std::cout << "[情報] MainGameSceneを終了.\n";
 }
+
+/**
+* 新規アクターを追加する.
+*
+* @param p 追加するアクターのポインタ.
+*/
+void MainGameScene::AddActor(ActorPtr p)
+{
+  newActors.push_back(p);
+}
+
+/**
+* プレイヤーアクターを取得する.
+*
+* @return プレイヤーアクターへのポインタ.
+*/
+ActorPtr MainGameScene::GetPlayerActor()
+{
+  return playerActor;
+}
```

これで`MainGameScene`クラスの外側から新規アクターを追加したり、プレイヤーアクターを参照したりできるようになりました。

### 1.11 ゾンビアクターにMainGameSceneのポインタを渡す

`MainGameScene`の対応は完了したので、次はゾンビアクターが`MainGameScene`クラスのメンバ関数を呼び出せるようにします。`ZombieActor.h`を開き、次のプログラムを追加してください。

```diff
 #ifndef ZOMBIEACTOR_H_INCLUDED
 #define ZOMBIEACTOR_H_INCLUDED
 #include "../Actor.h"

+// 先行宣言.
+class MainGameScene;

 /**
 * ゾンビアクター.
 */
 class ZombieActor : public Actor
 {
 public:
-  ZombieActor(const glm::vec3& pos, float rotY);
+  ZombieActor(const glm::vec3& pos, float rotY, MainGameScene* scene);
   virtual ~ZombieActor() = default;

   virtual void OnUpdate(float) override;
+
+private:
+  MainGameScene* mainGameScene = nullptr;
 };

 #endif // ZOMBIEACTOR_H_INCLUDED
```

`mainGameScene`メンバ変数は`private`(プライベート)キーワードの下にあるので、クラスのメンバからしか参照できなくなっています。クラスのメンバ以外が`mainGameScene`を参照できる必要はないからです。

このように`private`キーワードを使って、必要のないデータを外部から使えなくするのは、「抽象化」のひとつの例です。

また、ポインタまたは参照を引数にする場合、関数宣言の時点ではクラスの名前さえ分かっていれば十分で、クラス定義までは必要ありません。C++ではこの用途のために、クラス名だけを宣言できるようになっています。これは「先行宣言(せんこうせんげん)」と呼ばれています。

もちろん、実際に`MainGameScene`クラスのメンバ関数を使うときにはクラスの定義が分かっている必要があります。そこで、`ZombieActor.cpp`に`MainGameScene.h`をインクルードします。`ZombieActor.cpp`を開き、次のプログラムを追加してください。

```diff
 * @file ZombieActor.cpp
 */
 #include "ZombieActor.h"
+#include "../MainGameScene.h"
 #include "../GameData.h"

 /**
 * コンストラクタ.
```

次にコンストラクタ引数で受け取った`MainGameScene`のアドレスをポインタ変数に代入します。`ZombieActor`のコンストラクタを次のように変更してください。

```diff
 * コンストラクタ.
 *
 * @param pos    アクターを配置する座標.
 * @param rotY   アクターの向き.
+* @param scene メインゲームシーンのアドレス.
 */
-ZombieActor::ZombieActor(const glm::vec3& pos, float rotY) :
+ZombieActor::ZombieActor(const glm::vec3& pos, float rotY,
+  MainGameScene* scene) :
   Actor("zombie", nullptr,
     std::make_shared<Texture::Image2D>("Res/zombie_male.tga"),
-    pos)
+    pos),
+  mainGameScene(scene)
 {
```

これで`MainGameScene`のアドレスを受け取れるようになったので、ゾンビアクターを作成するときに`MainGameScene`のアドレスを渡すように変更しましょう。`MainGameScene.cpp`を開き、`Initialize`メンバ関数を次のように変更してください。

```diff
     float rotY =
       std::uniform_real_distribution<float>(0, glm::radians(360.0f))(random);
     // アクターを作成.
     std::shared_ptr<Actor> actor =
-      std::make_shared<ZombieActor>(pos, rotY);
+      std::make_shared<ZombieActor>(pos, rotY, this);
     // 作成したアクターを、アクターリストに追加.
     actors.push_back(actor);
```

これで`MainGameScene`のアドレスが`ZombieActor`の`mainGameScene`ポインタ変数に代入されるようになりました。

### 1.12 ゾンビアクターの更新関数を移動する

ようやく本丸の「ゾンビアクターの更新処理の移動」に取り掛かることができます。次のように、`Update`メンバ関数にあるゾンビアクターの行動を処理するプログラムを、無関係なカッコまで切り取らないように注意しつつ`Ctrl+X`で切り取ってください。

なお、ここで「ゾンビアクターの更新処理」としているのは、ゾンビアクターの速度、向き、アニメーション、状態、攻撃範囲の変更を行うためのプログラムを指しています。

これまでのテキストの進め方によっては、プログラムの順序や書き方がテキストと微妙に違っていることもあるでしょう。その場合でも「この行はゾンビアクターの更新にあたるだろうか」ということを考えて、切り取るかどうかを決めてください。

```diff
   for (auto& e : actors) {
      // ゾンビアクターの場合.
     if (e->name == "zombie") {
-      // 攻撃中以外なら攻撃範囲を削除する.
-      if (e->state != Actor::State::attack && e->attackActor) {
-        e->attackActor->isDead = true;
-        e->attackActor = nullptr;
-      }
-
-                ・
-                ・
-                ・
-
-          if (angle <= glm::radians(30.0f)) {
-            // 攻撃アニメーションを再生.
-            e->SetAnimation(GameData::Get().anmZombieMaleAttack);
-            // アクターの状態変数を「攻撃」に変更.
-            e->state = Actor::State::attack;
-          }
-        }
-      }
     }
   }

   // 新規アクターが存在するなら、それをアクターリストに追加する.
   if (!newActors.empty()) {
```

続いて`ZombieActor.cpp`を開き、`OnUpdate`メンバ関数に切り取ったプログラムを貼り付けてください。

```diff
 * @param deltaTime 前回の更新からの経過時間(秒).
 */
 void ZombieActor::OnUpdate(float deltaTime)
 {
-  // ここにゾンビアクターを更新するプログラムを移動する.
+  // 攻撃中以外なら攻撃範囲を削除する.
+  if (e->state != Actor::State::attack && e->attackActor) {
+    e->attackActor->isDead = true;
+    e->attackActor = nullptr;
+  }
+
+  // ダメージ状態のときの処理.
+  if (e->state == Actor::State::damage) {
+
+            ・
+            ・
+            ・
+
+      if (angle <= glm::radians(30.0f)) {
+        // 攻撃アニメーションを再生.
+        e->SetAnimation(GameData::Get().anmZombieMaleAttack);
+        // アクターの状態変数を「攻撃」に変更.
+        e->state = Actor::State::attack;
+      }
+    }
+  }
 }
```

初期化プログラムで`this`に相当するのは`actor`変数でしたが、更新プログラムでは`e`変数が`this`に相当します。つまり`e->`を消す必要があります。

<pre class="tnmai_assignment">
<strong>【課題02】</strong>
貼り付けたゾンビの更新プログラムから全ての<code>e-&gt;</code>を削除しなさい。
</pre>

### 1.13 MainGameSceneのメンバ関数を呼び出す

残る問題は`newActors`変数と`playerActor`変数を使っている部分です。ここでようやく`MainGameScene`クラスに追加したメンバ関数が役立ちます。

`newActor`に攻撃範囲アクターを追加する処理は`AddActor`メンバ関数で置き換えられます。`OnUpdate`メンバ関数を次のように変更してください。

```diff
          // 攻撃判定を設定.
          attackActor->SetCylinderCollision(0.2f, -0.2f, 0.1f);
          attackActor->collision.blockOtherActors = false;
          // 攻撃範囲アクターを新規アクター配列に追加.
-         newActors.push_back(attackActor);
+         mainGameScene->AddActor(attackActor);
        }
      }
```

`playerAcotr`を参照している部分は`GetPlayerActor`メンバ関数で置き換えられます。`OnUpdate`メンバ関数を次のように変更してください。

```diff
       // 歩行状態のときの処理.
       else if (e->state == Actor::State::walk) {
         // プレイヤーのいる方向を計算.
-        const glm::vec3 dirPlayer = playerActor->position - e->position;
+        const glm::vec3 dirPlayer =
+          mainGameScene->GetPlayerActor()->position - e->position;
         // ゾンビの正面方向を計算.
         glm::vec3 front(std::cos(e->rotation.y), 0, -std::sin(e->rotation.y));
         // 左右どちらに回転するかを決めるために外積を計算.
```

これでようやく`Actor`クラスを継承した`ZombieActor`クラスを作成することができました。

プログラムが書けたらビルドして実行してください。クラスに置き換える前と同じようにゾンビが動作していたら成功です。

>**【まとめ】**<br>
>
>* クラスを定義するとき、クラス名に続けて`: public 基底クラス名`と書くことで基底クラスを「継承」した派生クラスを作ることができる。
>* 派生クラスのアドレスは基底クラスのポインタや参照に代入できる。
>* `virtual`キーワードを使うことでメンバ関数を「仮想関数」にすることができる。
>* 基底クラスの仮想関数は派生クラスで上書きできる。仮想関数を上書きすることを「オーバーライド」という。
>* 仮想関数を実行すると、ポインタや参照のクラスではなく、実際に指しているクラスの仮想関数が実行される。これを「ポリモーフィズム」という。

<div style="page-break-after: always"></div>

## 2. プレイヤーアクターを派生クラスにする

### 2.1 PlayerActorクラスを定義する

ゾンビに続いてプレイヤーも`Actor`の派生クラスにしていきます。`Res/Actors`フォルダに`PlayerActor.h`というファイルを追加してください。追加した`PlayerActor.h`を開き、次のプログラムを追加してください。

```diff
+/**
+* @file PlayerActor.h
+*/
+#ifndef PLAYERACTOR_H_INCLUDED
+#defien PLAYERACTOR_H_INCLUDED
+#include "../Actor.h"
+#include "../Texture.h"
+
+// 先行宣言.
+class MainGameScene;
+
+/**
+* プレイヤーアクター
+*/
+class PlayerActor : public Actor
+{
+public:
+  PlayerActor(const glm::vec3& pos, MainGameScene* scene);
+  virtual ~PlayerActor() = default;
+
+  void ProcessInput();
+
+private:
+  MainGameScene* mainGameScene = nullptr;
+  std::shared_ptr<Texture::Image2D> texBullet;
+};
+
+#endif // PLAYERACTOR_H_INCLUDED
```

プレイヤーアクターには弾丸を発射する能力が必要なので、ゾンビアクターと同様に`MainGameScene`クラスのポインタを持たせています。

また、プレイヤーアクターはキー入力によって操作できなくてはなりません。これは他のアクターにはない機能なので、キー入力を処理するための`ProcessInput`(プロセス・インプット)メンバ関数を定義することにしました。

なお`OnUpdate`メンバ関数は定義しません。というのは、現在のプレイヤーアクターは`Actor::Update`で行う以上の処理を必要としていないからです。

続いてメンバ関数を定義しましょう。`Res/Actors`フォルダに`PlayerActor.cpp`というファイルを追加してください。追加した`PlayerActor.cpp`を開き、次のプログラムを追加してください。

```diff
+/**
+* @file PlayerActor.cpp
+*/
+#include "PlayerActor.h"
+#include "../MainGameScene.h"
+#include "../GameData.h"
+
+/**
+* コンストラクタ.
+*
+* @param pos    アクターを配置する座標.
+* @param scene メインゲームシーンのアドレス.
+*/
+PlayerActor::PlayerActor(const glm::vec3& pos, MainGameScene* scene) :
+  Actor("player", nullptr,
+    std::make_shared<Texture::Image2D>("Res/player_male.tga"),
+    pos),
+  mainGameScene(scene)
+{
+  // 弾丸テクスチャを読み込む.
+  texBullet = std::make_shared<Texture::Image2D>("Res/Bullet.tga");
+}
+
+/**
+* プレイヤーアクターの入力処理.
+*/
+void PlayerActor::ProcessInput()
+{
+}
```

`PlayerActor`で定義するのはコンストラクタと`ProcessInput`の2つだけです(少なくとも今のところは)。コンストラクタで基底クラスを初期化するには「`:`のあとに基底クラスのコンストラクタを書く」のでしたね。

また、ゾンビアクターとは異なりコンストラクタに「向き」を指定する機能はありませんが、これはもともとプレイヤーアクターには「向き」を設定していなかったからです。

プレイヤーアクターは「プレイヤーの操作で自由に向きを変えられる」ので、大抵はゲームを開始するとすぐに向きが変わってしまいます。そのため、(少なくとも現在のゲーム内容では)最初の向きを設定しておく意味はほぼありません。

### 2.2 プレイヤーアクターの作成処理をコンストラクタに移動する

それではプレイヤーアクターの作成処理を`MainGameScene`から移動しましょう。

次のように、`Initialize`メンバ関数にあるプレイヤーアクターを作成するプログラムを`Ctrl+X`で切り取ってください。このとき無関係な部分は切り取らないように注意してください。

```diff
   // プレイヤーアクターを作成.
   playerActor = std::make_shared<Actor>(
     &GameData::Get().primitiveBuffer.Get(PrimNo::player_idle_0),
     texPlayer, glm::vec3(10, 0, 10));
-  playerActor->health = 10;
-  playerActor->SetAnimation(GameData::Get().anmPlayerIdle);
-  // 垂直円柱型の衝突判定を設定.
-  playerActor->SetCylinderCollision(1.7f, 0.0f, 0.25f);
-  // 衝突処理を設定.
-  playerActor->OnHit = [](Actor& a, Actor& b, void* option) {
-
-          ・
-          ・
-          ・
-
-        a.velocity = glm::vec3(0);
-        // 倒れるアニメーションを再生.
-        a.SetAnimation(GameData::Get().anmPlayerDead);
-        // 状態を「死亡」にする.
-        a.state = Actor::State::dead;
-      }
-    }
-  };

   // 作成したプレイヤーアクターを、アクターリストに追加.
   actors.push_back(playerActor);

   // ゾンビアクターを作成.
   for (size_t i = 0; i < 100; ++i) {
     glm::vec3 pos(0);
```

次に`PlayerActor.cpp`を開き、コンストラクタに`Ctrl+V`で貼り付けてください。

```diff
     std::make_shared<Texture::Image2D>("Res/player_male.tga"),
     pos),
   mainGameScene(scene)
 {
+  playerActor->health = 10;
+  playerActor->SetAnimation(GameData::Get().anmPlayerIdle);
+  // 垂直円柱型の衝突判定を設定.
+  playerActor->SetCylinderCollision(1.7f, 0.0f, 0.25f);
+  // 衝突処理を設定.
+  playerActor->OnHit = [](Actor& a, Actor& b, void* option) {
+
+          ・
+          ・
+          ・
+
+        a.velocity = glm::vec3(0);
+        // 倒れるアニメーションを再生.
+        a.SetAnimation(GameData::Get().anmPlayerDead);
+        // 状態を「死亡」にする.
+        a.state = Actor::State::dead;
+      }
+    }
+  };
   // 弾丸テクスチャを読み込む.
   texBullet = std::make_shared<Texture::Image2D>("Res/Bullet.tga");
 }
```

`ZombieActor`クラスではアクター変数を`this`に変えて削除しました。`PlayerActor`クラスでも同じことを行う必要があります。そのために、以下の課題03を完了させてください。

<pre class="tnmai_assignment">
<strong>【課題03】</strong>
貼り付けたプレイヤーアクターを作成するプログラムから全ての<code>playerActor-&gt;</code>を削除しなさい。このとき「、<code>position</code>ローカル変数の名前ががメンバ変数と重複してしまうので、ローカル変数の名前を<code>pos</code>に変更すること(ローカル変数を使っている場所の変更を忘れないように)。
</pre>

初期化の対象が`playerActor`変数から`this`変数に変わっただけなので、この部分の変更をするだけでプログラムの移動は完了します。

### 2.3 PlayerActorのインスタンスを作成する

コンストラクタが完成したので、メインゲームシーンを`PlayerActor`クラスを使うように変更しておきましょう。

まずヘッダファイルをインクルードします。`MainGameScene.cpp`を開き、次のプログラムを追加してください。

```diff
 #include "MainGameScene.h"
 #include "GameData.h"
 #include "SceneManager.h"
+#include "Actors/PlayerActor.h"
 #include "Actors/ZombieActor.h"
 #include <glm/gtc/matrix_transform.hpp>
 #include <iostream>
```

次に、`Initialize`メンバ関数の中にある「プレイヤーアクターを作成するプログラム」を次のように変更してください。

```diff
   // プレイヤーアクターを作成.
-  playerActor = std::make_shared<Actor>(
-    &GameData::Get().primitiveBuffer.Get(PrimNo::player_idle_0),
-    texPlayer, glm::vec3(10, 0, 10));
+  playerActor = std::make_shared<PlayerActor>(glm::vec3(10, 0, 10), this);

   // 作成したプレイヤーアクターを、アクターリストに追加.
   actors.push_back(playerActor);
```

これで`PlayerActor`のインスタンスが作成されるようになりました。

### 2.4 プレイヤーアクターの入力処理を移動する

続いて「プレイヤーアクターを操作するための入力処理」を移動します。`ProcessInput`メンバ関数のかなりの部分が「プレイヤーアクターを操作する」ためのプログラムで占められているので、`ProcessInput`の大半を移動させることになるでしょう。

なお、ここでいう「入力処理」には「マウスカーソル座標をワールド座標に変換」するプログラムも含まれます。この変換プログラム自体にはキー入力処理などはありませんが、プレイヤーアクターの向きを決めるためにはどうしても必要になるからです。

また、弾の発射処理もすべて「入力処理」に含まれます。発射のためにキー入力を処理する必要がありますし、なにより弾を発射するのはプレイヤーアクター自身だからです。

それでは、`ProcessInput`メンバ関数にある「プレイヤーアクターを操作するための入力処理」に当たるプログラムをすべて選択し、`Ctrl+X`で切り取ってください。

```diff
       playerActor->rotation.y = std::atan2(
         playerActor->position.z - posMouseCursor.z,
         posMouseCursor.x - playerActor->position.x);
     }
   }

-  // プレイヤーアクターを移動させる.
-  glm::vec3 direction = glm::vec3(0);
-  if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {
-    direction.x -= 1;
-  } else if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) {
-
-                ・
-                ・
-                ・
-
-    // 衝突処理を設定.
-    bullet->OnHit = [](Actor& a, Actor& b, void* option) {
-      // 衝突先が弾丸またはプレイヤーの場合は何もしない.
-      if (b.name == "bullet" || b.name == "player") {
-        return;
-      }
-      // 弾丸アクターを消す.
-      a.isDead = true;
-    };
-
-    // アクターをリストに追加.
-    actors.push_back(bullet);
-  }
 }

 /**
 * メインゲーム画面を更新する.
```

切り取ったら、次は`PlayerActor.cpp`を開き、プレイヤーアクターの`ProcessInput`メンバ関数の中に`Ctrl+V`で貼り付けてください。

```diff
 void PlayerActor::ProcessInput()
 {
+  // プレイヤーアクターを移動させる.
+  glm::vec3 direction = glm::vec3(0);
+  if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {
+    direction.x -= 1;
+  } else if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) {
+
+                ・
+                ・
+                ・
+
+    // 衝突処理を設定.
+    bullet->OnHit = [](Actor& a, Actor& b, void* option) {
+      // 衝突先が弾丸またはプレイヤーの場合は何もしない.
+      if (b.name == "bullet" || b.name == "player") {
+        return;
+      }
+      // 弾丸アクターを消す.
+      a.isDead = true;
+    };
+
+    // アクターをリストに追加.
+    actors.push_back(bullet);
+  }
 }

/**
 * プレイヤーアクターの入力処理.
```

<pre class="tnmai_assignment">
<strong>【課題04】</strong>
貼り付けたプレイヤーアクターを作成するプログラムから全ての<code>playerActor-&gt;</code>を削除しなさい。
</pre>

### 2.5 弾丸アクターの追加処理を修正する

さて、今回は`playerActor`変数を削除しただけでは足りず、まだエラーが残っています。原因は弾丸アクターを追加するときに`actors`変数が見えていないことです。

インゲームシーンにアクターを追加するには、`mainGameScene`変数経由で`AddActor`メンバ関数を呼び出します。`ProcessInput`メンバ関数を次のように変更してください。

```diff
       // 弾丸アクターを消す.
       a.isDead = true;
     };

     // アクターをリストに追加.
-    actors.push_back(bullet);
+    mainGameScene->AddActor(bullet);
   }
 }
```

これで入力処理を移動することができました。

<pre class="tnmai_assignment">
<strong>【課題05】</strong>
ところで、プレイヤーアクターの移動を制御するキー入力処理は、まだ<code>glfwGetKey</code>関数を使っていると思います。移動を制御するキー入力処理を<code>GameData</code>クラスの<code>keyPressed</code>メンバ変数を使うように変更しなさい。
</pre>

### 2.6 プレイヤーの向きをPlayerActorクラスで設定する

プレイヤーアクターの向きはまだ`MainGameScene`で設定しています。これもプレイヤーアクター自身が設定できるようにします。マウスカーソル座標の計算はメインゲームシーンに残し、プレイヤーアクターではメインゲームシーンからカーソル座標を取得するようにします。

`MainGameScene.h`を開き、次のプログラムを追加してください。

```diff
   void AddActor(ActorPtr p);
   ActorPtr GetPlayerActor();
+  const glm::vec3& GetMouseCursor() const;

 private:
   std::shared_ptr<Texture::Image2D> texGround = nullptr;
   std::shared_ptr<Texture::Image2D> texTree = nullptr;
```

次に`MainGameScene.cpp`を開き、次のプログラムを追加してください。

```diff
 {
   return playerActor;
 }
+
+/**
+* マウスカーソル座標を取得する.
+*
+* @return マウスカーソル座標.
+*/
+const glm::vec3& MainGameScene::GetMouseCursor() const
+{
+  return posMouseCursor;
+}
```

次に`MainGameScene`からプレイヤーアクターの向きを設定する部分だけを削除します。`ProcessInput`メンバ関数のマウスカーソル座標の計算を次のように変更してください。

```diff
     const Plane plane = {
       playerActor->position + glm::vec3(0, 1, 0), glm::vec3(0, 1, 0) };
     // マウスカーソル線分とXZ平面の交点を求める.
-    if (Intersect(seg, plane, &posMouseCursor)) {
+    Intersect(seg, plane, &posMouseCursor);
-      // 交点からプレイヤーアクターの向きを計算.
-      playerActor->rotation.y = std::atan2(
-        playerActor->position.z - posMouseCursor.z,
-        posMouseCursor.x - playerActor->position.x);
-    }
   }

   // プレイヤーアクターを移動させる.
   glm::vec3 direction = glm::vec3(0);
```

最後に先程削除したプレイヤーアクターの向き設定プログラムを、`PlayerActor`クラスに移植します。`PlayerActor.cpp`を開き、`ProcessInput`メンバ関数に次のプログラムを追加してください。

```diff
 void PlayerActor::ProcessInput()
 {
+  // マウスカーソル座標からプレイヤーアクターの向きを計算.
+  const glm::vec3 posMouseCursor = mainGameScene->GetMouseCursor();
+  rotation.y = std::atan2(
+    position.z - posMouseCursor.z,
+    posMouseCursor.x - position.x);
+
   // プレイヤーアクターを移動させる.
   glm::vec3 direction = glm::vec3(0);
   if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {
```

これでプレイヤーアクターの向きも、プレイヤーアクター自身が設定できるようになりました。

### 2.7 PlayerActorのProcessInputメンバ関数を呼び出す

入力処理の移動ができたので、あとは、もともと入力処理があった`MainGameScene`の`ProcessInput`メンバ関数から、`PlayerActor`の`ProcessInput`メンバ関数を呼び出すだけです。

`MainGameScene.cpp`を開き、`ProcessInput`メンバ関数を次のように変更してください。

```diff
     if (gamedata.keyPressedInLastFrame & GameData::Key::enter) {
       SceneManager::Get().ChangeScene(SCENENAME_TITLE);
     }
     return;
   }

+  // プレイヤーアクターの入力処理.
+  playerActor->ProcessInput();
 }

 /**
 * メインゲーム画面を更新する.
```

…おかしいですね、エラーになってしまいます。`PlayerActor`クラスには`ProcessInput`メンバ関数を宣言してあるはずなんですが。Visual Studioがバグってるのでしょうか？ もちろんそんなことはありません。ちゃんと原因があります。それは、

>`playerActor`変数は`Actor`クラスのポインタである(`PlayerActor`クラスのポインタではない)

ということです。

`Actor`クラスには`ProcessInput`というメンバ関数はないので、呼び出そうとすればエラーになるのは当然です。`ProcessInput`メンバ関数を呼び出すには次の方法が考えられます。

1. 変数の型を「`Actor`クラスのポインタ」から「`PlayerActor`クラスのポインタ」に変更する。
2. `ProcessInput`メンバ関数を呼び出すときに「`PlayerActor`クラスのポインタ」へキャストする。

どちらの方法でもエラーはなくなりますが、「キャスト」はバグを生みやすく基本的に避けたほうがよいので、今回はより安全な`1`の方法を使います。

まず`MainGameScene.h`を開き、次のように`PlayerActor.h`をインクルードしてください。

```diff
 #include "Texture.h"
 #include "Actor.h"
+#include "Actors/PlayerActor.h"
 #include <memory>

 /**
 * メインゲーム画面.
 */
```

これで`PlayerActor`クラスが使えるようになりました。続いて`playerActor`変数の型を次のように変更してください。

```diff
   std::shared_ptr<Texture::Image2D> texPlayer;
   Shader::PointLight pointLight;

   ActorList actors; // アクター配列.
-  ActorPtr playerActor; // プレイヤーアクター.
+  std::shared_ptr<PlayerActor> playerActor; // プレイヤーアクター.

   // 出現させる敵の数.
   size_t appearanceEnemyCount = 10;

   // クリア条件を満たしたかどうか.
```

この変更で`ProcessInput`メンバ関数を呼び出せるようになったはずです。プログラムが書けたらビルドして実行してください。これまでどおりプレイヤーアクターが操作できていたら成功です。

さて、ゾンビアクターとプレイヤーアクターをそれぞれ別のクラスとして分離したことで、メインゲームシーンのプログラムはずいぶん簡素になりました。

メインゲームシーンには、アクターの作成と描画、それからゲームクリア及びゲームオーバーの処理といった「シーンが管理しなくてはならない出来事」だけが残りました。

また、ゾンビアクタークラスにはゾンビを操作するプログラムだけ、プレイヤーアクタークラスにはプレイヤーアクターを操作するプログラムだけ、というように、各クラスは「自分自身に関わる処理」だけを行うようになりました。

ここまで見てきたように、C++言語のクラスや継承といった機能は、オブジェクト指向による「クラスごとの責任の分離」を容易にするためのものです。

>**【まとめ】**<br>
>
>* オブジェクトの初期化や更新などの処理をオブジェクト自身のメンバとして定義することで、オブジェクトごとに作業を分担できる。
>* 継承したクラスで通常の(仮想関数でない)メンバ関数を作ってもよい。
>* 個々のオブジェクトが受け持つ責任を考慮してクラスを作ることが重要。

<div style="page-break-after: always"></div>

## 3. 重力

### 3.1 アクターに重力をかける

アクターが惑星上に存在するのであれば星の重力の影響を受けるはずですが、今はそうなっていません。しかし、現実的なジャンプや放物線を描く運動を表現するには避けては通れません。そこでこの章ではアクターに重力が影響するようにしていきます。

まずは重力定数を定義しましょう。重力はゲーム全体で利用するので`GameData.h`のメンバ変数として定義するのが良いでしょう。メンバ変数名は`gravity`(グラビティ)とします。`GameData.h`を開き、次のプログラムを追加してください。

```diff
   // 倒したゾンビの数.
   size_t killCount = 0;
+
+  // 重力.
+  glm::vec3 gravity = glm::vec3(0, -9.8f, 0);

 private:
   GameData() = default;
   ~GameData();
```

上記のプログラムにおいて`-9.8f`は地球の平均的な重力加速度である`9.8m/s²`を表しています。マイナスなのは重力が下向きに働くからです。

重力は「<ruby>等加速度直線運動<rt>とうかそくどちょくせんうんどう</rt></ruby>」なので、その影響は「速度」対して現れます。アクターの速度は`velocity`メンバ変数で表されますから、`velocity`を一定の速度で増加させれば等加速度直線運動になります。

`Actor.cpp`を開き、次のように`GameData.h`をインクルードしてください。

```diff
 * @file Actor.cpp
 */
 #include "Actor.h"
+#include "GameData.h"
 #include <glm/gtc/matrix_transform.hpp>
 #include <algorithm>
```

これで`gravity`を参照できるようになりましたので、`velocity`に重力の影響を加えます。`Update`メンバ関数に次のプログラムを追加してください。

```diff
 void Actor::Update(float deltaTime)
 {
   OnUpdate(deltaTime);
+
+  // 移動速度に重力を加算.
+  velocity += GameData::Get().gravity * deltaTime;

  // 座標を更新.
  position += velocity * deltaTime;
```

プログラムが書けたらビルドして実行してください。ゾンビやプレイヤーアクターがゆっくりと落下し、家や木や立方体が速く落下していたら成功です。

### 3.2 重力の影響を制御する

地面以外がみな落下していくのは地面に衝突判定がないからですが、衝突判定を付けただけでは解決しません。現実世界では地面には物質が詰まっているため落下していくことはありませんが、ゲーム世界では中身の詰まった地面などないのが普通だからです。

そのため、多くのゲームでは重力が働くのは一部のアクターだけで、地形などには重力が働かないようになっています。

そこで、アクターごとに重力の影響率を設定できるようにして、「重力と影響率を掛けた値」をベロシティに加算するようにします。この影響率を`gravitiScale`(グラビティ・スケール)と名付けましょう。

`Actor.h`を開き、`Actor`クラスの定義に次のプログラムを追加してください。

```diff
   // 衝突解決関数へのポインタ.
   void (*OnHit)(Actor&, Actor&, void*) = [](Actor&, Actor&, void*) {};

   std::shared_ptr<Actor> attackActor; // 攻撃の衝突判定用アクター.
+
+  float gravityScale = 0; // 重力の影響率.

   bool isDead = false; // 死亡フラグ.
 };
```

重力の影響を「受ける・受けない」という2パターンにせず`float`型にしたのは、空気抵抗のような効果を再現できるようにするためです。

次に`Actor.cpp`を開き、`Update`メンバ関数の重力処理を次のように変更してください。

```diff
   OnUpdate(deltaTime);

   // 移動速度に重力を加算.
+  if (gravityScale) {
-    velocity += GameData::Get().gravity * deltaTime;
+    velocity += GameData::Get().gravity * gravityScale * deltaTime;
+  }

  // 座標を更新.
  position += velocity * deltaTime;
```

これで家や木が落下していくことはなくなるはずです。プログラムが書けたらビルドして実行してください。家、木、立方体が落下しなくなっていたら成功です。

### 3.3 ゾンビアクターが重力の影響を受けるようにする

地形の問題は解決したので、ゾンビとプレイヤーがゆっくり落下する問題を解決します。

ゾンビとプレイヤーの落下速度が家や木と違っていたのは、`Update`メンバ関数や `ProcessInput`メンバ関数の中でベロシティを上書きしているからです。

現在の重力はY方向にかかるので、ベロシティのY要素を上書きしないようにすれば問題は解決します。`ZombieActor.cpp`を開き、`Update`メンバ関数のベロシティを設定するプログラムを次のように変更してください。

```diff
         front.y = 0;
         front.z = -std::sin(e->rotation.y);
         // 正面方向に1m/sの速度で移動するように設定.
-        velocity = front;
+        velocity.x = front.x;
+        velocity.z = front.z;
         state = Actor::State::walk;

         // プレイヤーが距離3m以内かつ前方左右30度以内にいたら攻撃.
         const float distanceSq = glm::dot(dirPlayer, dirPlayer);
```

これで歩行時のY要素は変更されなくなります。それからもう一箇所、ゾンビが死んだときにもベロシティを操作しているので、こちらも修正します。`Initialize`メンバ関数の衝突処理関数を次のように変更してください。

```diff
         // 衝突判定を無くす.
         a.collision.shape = Collision::Shape::none;
         // 速度を0にする.
+        a.velocity.x = 0;
+        a.velocity.z = 0;
         // 死亡状態にする.
         a.state = Actor::State::dead;
         // 倒したゾンビの数を1体増やす.
```

最後に重力の影響率を設定します。影響率の初期値は`0`なので、重力の影響させたいアクターは必ず影響率を設定しなくてはなりません。`Initialize`メンバ関数似次のプログラムを追加してください。

```diff
     std::make_shared<Texture::Image2D>("Res/zombie_male.tga"),
     pos)
 {
+  // 重力の影響率を設定.
+  gravityScale = 1;
   // アクターの耐久値を設定.
   health = 3;
   // 垂直円柱型の衝突判定を設定.
```

プログラムが書けたらビルドして実行してください。ゾンビの落下速度が速くなっていたら成功です。

### 3.4 プレイヤーアクターが重力の影響を受けるようにする

ゾンビアクターに続いて、プレイヤーアクターも重力の影響を受けるようにしましょう。やることはゾンビアクターと一緒で、ベロシティのY要素を設定しないようにすることと重力の影響率を設定することです。

`PlayerActor.cpp`を開き、`ProcessInput`メンバ関数を次のように変更してください。

```diff
     // 正規化することで、ななめ移動でも同じ速度で移動させる.
     const float speed = 4.0f; // プレイヤーアクターの速度(メートル毎秒).
-    velocity = glm::normalize(direction) * speed;
+    direction = glm::normalize(direction);
+    velocity.x = direction.x * speed;
+    velocity.z = direction.z * speed;
     // 走りアニメを設定.
     SetAnimation(GameData::Get().anmPlayerRun);
   } else {
-    velocity = glm::vec3(0);
+    velocity.x = 0;
+    velocity.z = 0;
     // 待機アニメを設定.
     SetAnimation(GameData::Get().anmPlayerIdle);
   }

   // Jキーで弾丸を発射する.
```

続いて`Initialize`メンバ関数に次のプログラムを追加してください。

```diff
     std::make_shared<Texture::Image2D>("Res/player_male.tga"),
     pos),
   mainGameScene(scene)
 {
+  // 重力の影響率を設定.
+  gravityScale = 1;
+
   health = 10;
   SetAnimation(GameData::Get().anmPlayerIdle);
   // 垂直円柱型の衝突判定を設定.
```

プログラムが書けたらビルドして実行してください。プレイヤーアクターが速い速度で落下していったら成功です。

<pre class="tnmai_assignment">
<strong>【課題06】</strong>
プレイヤーアクターが死亡したときにもベロシティを上書きしています。プレイヤーアクターが死亡したときにベロシティのX、Z要素だけ0にするようにプログラムを変更しなさい。
</pre>

正常に落下できるようになったので、地面に衝突判定を設定して落下しないようにしましょう。

<pre class="tnmai_assignment">
<strong>【課題07】</strong>
地面をアクタークラスを使って表示しなさい。地面の衝突判定の形状は直方体とし、衝突判定のX軸方向とZ軸方向の長さは地面のモデルと同じ長さ、Y軸方向は上端を<code>0m</code>、下端を<code>-10m</code>に設定しなさい。
</pre>

課題07が完了したら、ビルドして実行してください。ゾンビとプレイヤーアクターが落下しなくなっていたら成功です。

### 3.5 垂直円柱と直方体の衝突判定を修正する

地面ができて落下しなくなったはずですが、木に押し付けられるような状態になると、突然なにもない空間に落下してしまうことがあります。

これは実は、第12回で作成した垂直円柱と直方体の衝突判定プログラムに計算ミスがあったためです。`Actor.cpp`を開き、`CollideCylinderAndBox`関数の長さ計算プログラムを、次のように修正してください。

```diff
     const float cz = b.position.z +
       (b.collision.boxMin.z + b.collision.boxMax.z) * 0.5f;

     // 直方体のX及びZ軸方向の中心座標からの長さ(hx, hz)を計算.
-    const float hx = b.collision.boxMax.x - cx;
-    const float hz = b.collision.boxMax.z - cz;
+    const float hx = (b.collision.boxMax.x - b.collision.boxMin.x) * 0.5f;
+    const float hz = (b.collision.boxMax.z - b.collision.boxMin.z) * 0.5f;

     // 直方体の中心座標から円柱の中心軸までの距離(ox, oz)を計算.
     const float ox = a.position.x - cx;
```

直方体の大きさが正しく計算されなかったため、押し出される距離が非常に大きくなり、地面から遠く離れた位置に移動させられていたわけです。

それから、垂直円柱が上に押し出された場合はジャンプ等で直方体の縁を乗り越えたか、落下して直方体の上に乗ったかのいずれかです。もし落下していたらベロシティのY要素を0にします。 `CollideCylinderAndBox`関数に次のプログラムを追加してください。

```diff
     // そうでなければ円柱を下に移動.
     if (bottomA > bottomB) {
       a.position.y += topB - bottomA; // Aを上に移動.
+      // 落下(速度のY要素が0未満)していたらY要素を0にする.
+      a.velocity.y = std::max(a.velocity.y, 0.0f);
     } else {
       a.position.y -= topA - bottomB; // Aを下に移動.
```

上下に衝突したときにY要素を0にしないと、際限なく重力で加速されて、最後には直方体にめり込んで横に押し出されてしまいます。

プログラムを修正したらビルドして実行してください。木に押し付けられたとき、遠く離れた位置に押し出されなくなっていたら成功です。なお、ゾンビが積み重なっていく現象については次の節で対応します。

### 3.6 垂直円柱同士の衝突判定を修正する

ゾンビが積み重なっていくのは、ゾンビ同士の座標がぴったり重なっていたら上下方向に押し出すようになっているからです。つまり積み重ならないようにしたければ、座標がぴったり重なっていても、なんとかして横に押し出すようにすればいいはずです。

問題は、中心座標の差を利用して押し出す方向を決めているため、完全に重なっていると方向を決められないことです。そこで、ぴったり重なっていた場合に押し出す方向を決める新しいルールを追加することにします。

どんなルールがいいかは悩ましいところですが、今回は単純に「+X方向に押し出す」ことにしました。ルールが単純な方がバグを作りにくく、もしバグがあっても対処しやすいからです。

また、現在は円柱の垂直方向の半分以上が直方体に埋まると横に押し出すようになっていますが、これだと地面に少しめり込んだだけで横に押し出されることがあります。そこで条件を多少緩和して「3/4」以上めり込んだら横に押し出すようにしてみます。

```diff
   // 短いほうの円柱の高さを取得.
   const float shortY = std::min(topA - bottomA, topB - bottomB);

-  // 重なっている長さが短い方の円柱の高さの半分未満なら上に押し返す.
-  // 半分以上なら横に押し返す.
-  // 押し返す方向を計算できない場合(d2が0の場合)も上に押し返す.
-  if (overlapY < shortY * 0.5f || d2 < 0.0001f) {
+  // 重なっている長さが円柱の3/4未満なら上または下に押し返す.
+  // 3/4以上なら横に押し返す.
+  // 押し返す方向を計算できない場合(d2が0の場合)+X方向に押し返す.
+  if (overlapY < shortY * 0.75f) {
     // 下端が高い位置にあるアクターを上に移動.
     if (bottomA > bottomB) {
       a.position.y += topB - bottomA; // Aを上に移動.
+      // Aが下方向に移動していたらAの速度のY要素を0にする.
+      a.velocity.y = std::max(0.0f, a.velocity.y);
     } else {
       b.position.y += topA - bottomB; // Bを上に移動.
+      // Bが下方向に移動していたらBの速度のY要素を0にする.
+      b.velocity.y = std::max(0.0f, b.velocity.y);
     }
+  } else if (d2 < 0.0001f) {
+    // アクターAとBを均等に押し返す.
+    const glm::vec3 n(1, 0, 0);
+    a.position += n * r * 0.5f;
+    b.position -= n * r * 0.5f;
   } else {
     // 中心間の距離dを計算.
     const float d = std::sqrt(d2);
```

プログラムが書けたらビルドして実行してください。ゾンビが積み重なる現象がなくなっていれば成功です。

### 3.7 死んだゾンビに衝突判定を付ける

ゾンビが死亡すると落下していきます。これはゾンビが死んだ瞬間に衝突判定を消しているからです。ゾンビが落下しないようにするには、死んだ瞬間に衝突判定を消すのではなく、倒れた状態に合わせた小さな衝突判定を設定すれば解決します。

`ZombieActor.cpp`を開き、`OnHit`メンバ変数に設定する衝突処理関数を次のように変更してください。

```diff
       } else {
         // 死亡アニメーションを設定.
         a.SetAnimation(GameData::Get().anmZombieMaleDown);
-        // 衝突判定を無くす.
-        a.collision.shape = Collision::Shape::none;
+        // 衝突判定を小さくする.
+        a.SetCylinderCollision(0.3f, 0.0f, 0.3f);
         // 速度を0にする.
         a.velocity.x = 0;
```

プログラムが書けたらビルドして実行してください。ゾンビが死んだときに落下しなければ成功です。

### 3.8 プレイヤーをジャンプさせる

せっかく重力が働くようになったので、プレイヤーにジャンプさせてみましょう。まずジャンプ操作用のキーを定義します。`GameData.h`を開き、`Key`列挙型に次のプログラムを追加してください。

```diff
     up    = 0b0000'0000'0000'1000, // 矢印キー(上)
     down  = 0b0000'0000'0001'0000, // 矢印キー(下)
     shot  = 0b0000'0000'0010'0000, // 弾発射キー
+    jump  = 0b0000'0000'0100'0000, // ジャンプキー
   };
   uint32_t keyPressed = 0;            // 押しているキー.
```

次にキーマップにジャンプキーに対応するキーを設定します。ジャンプ列挙子に対応するキーには「スペースバー」を使うことにしましょう。`GLFW`ライブラリでは、スペースバーのキー番号は`GLFW_KEY_SPACE`で表されます。

`GameData.cpp`を開き、`Update`メンバ関数にある`keyMap`配列に次のプログラムを追加してください。

```diff
       { Key::right, GLFW_KEY_D },
       { Key::up,    GLFW_KEY_W },
       { Key::down,  GLFW_KEY_S },
+      { Key::jump,  GLFW_KEY_SPACE },
     };

     // 現在押されているキーを取得.
```

これでスペースバーを押すと`Actor::Key::jump`ビットが変化するようになります。

それではプレイヤーアクターにジャンプ機能を追加しましょう。「ジャンプの予備動作を待つ」のような特別なことをしない場合、アクターをジャンプさせるにはベロシティのY要素に数値を設定するだけで十分です。

`PlayerActor.cpp`を開き、`ProcessInput`メンバ関数に次のプログラムを追加してください。

```diff
     // 待機アニメを設定.
     SetAnimation(GameData::Get().anmPlayerIdle);
+
+  // ジャンプ.
+  if (GameData::Get().keyPressedInLastFrame & GameData::Key::jump) {
+    velocity.y = 5.0f;
+  }

   // Jキーで弾丸を発射する.
   if (gamedata.keyPressedInLastFrame & GameData::Key::shot) {
```

プログラムが書けたらビルドして実行してください。スペースバーを押すたびにプレイヤーがジャンプしたら成功です。

>**【ジャンプの初速と最大高度】**<br>
>ジャンプの最大高度は以下の式で計算できます。<br>
>`最大高度 = 初速×初速÷(2×重力加速度)`<br>
>重力加速度は`9.8m/s²`だと分かっているので、初速が`5m/s`の場合の最大高度は<br>
>`最大高度 = 5×5÷(2×9.8)`<br>
>からおよそ`1.28m`だということが分かります。

<br>

>**【まとめ】**<br>
>
>* 重力は等加速度直線運動なので`position`ではなく`velocity`が変化する。
>* 移動を止めるときは、重力が影響する要素を変更しない。
>* アクターに衝突判定を付けないと永遠に落下しつづける。
>* キー操作の種類を増やすには`Key`列挙値と`keyMap`配列にキーを追加する。
